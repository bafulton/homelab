# Claude Context for Homelab

## Git Workflow

Commit directly to main for routine changes. Use PRs for larger changes that benefit from review.

## Project Overview

GitOps-driven Kubernetes homelab running on Talos Linux with Tailscale networking. Tailnet: `catfish-mountain.ts.net`

## Repository Structure

```
homelab/
├── charts/                   # Reusable Helm charts
├── talos/                    # Talos Linux configuration
├── tailscale/                # Tailscale GitOps config
└── kubernetes/               # GitOps manifests (managed by ArgoCD)
    ├── applications.yaml     # Root app-of-apps (applied during bootstrap)
    ├── appsets/              # ApplicationSets that generate ArgoCD apps
    │   ├── infra.yaml        # Generates apps for infra/
    │   └── apps.yaml         # Generates apps for apps/
    ├── infra/                # Infrastructure Helm charts
    └── apps/                 # User applications (none yet)
```

## GitOps Pattern

Each app in `infra/` or `apps/` is a wrapper Helm chart:
- `Chart.yaml` - Declares upstream chart as dependency
- `values.yaml` - Configuration values (also read by ApplicationSet for metadata)
- `templates/` - Additional resources (e.g., Tailscale Ingress, Secrets)

The ApplicationSets scan for `values.yaml` files and generate ArgoCD Applications automatically.

### Adding a New App

1. Create directory: `kubernetes/infra/my-app/` or `kubernetes/apps/my-app/`
2. Add `Chart.yaml` with upstream dependency
3. Add `values.yaml` with configuration
4. Commit and push - ArgoCD auto-syncs

### Values.yaml Conventions

```yaml
# Optional: Override namespace (defaults to directory name)
namespace: custom-namespace

# Optional: Enable server-side apply for CRD-heavy charts
serverSideApply: true

# Tailscale exposure (if using tailscale-ingress template)
tailscale:
  enabled: true
  hostname: my-app  # becomes my-app.catfish-mountain.ts.net

# Upstream chart values nested under chart name
my-upstream-chart:
  key: value
```

## Important Patterns

### Tailscale Ingress

Services are exposed via Tailscale Ingress (not traditional Ingress controllers):
- Tailscale operator creates proxy pods that join the tailnet
- TLS certificates are automatically provisioned via Let's Encrypt
- Access via `https://<hostname>.catfish-mountain.ts.net`

Template pattern (`templates/tailscale-ingress.yaml`):
```yaml
{{- if .Values.tailscale.enabled }}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ .Release.Name }}
spec:
  ingressClassName: tailscale
  defaultBackend:
    service:
      name: {{ .Release.Name }}
      port:
        number: 80
  tls:
    - hosts:
        - "{{ .Values.tailscale.hostname }}"
{{- end }}
```

### PodSecurity

Kubernetes enforces PodSecurity standards. Most namespaces use "baseline" but some require "privileged":
- `longhorn` - Storage operations require privileged access
- `metallb` - Speaker needs NET_RAW, hostNetwork for L2/ARP

Add namespace template with labels if privileged access needed:
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: {{ .Release.Namespace }}
  labels:
    pod-security.kubernetes.io/enforce: privileged
```

## Secrets Management

**Bootstrap secrets** (created during `bootstrap.sh`):
- **ArgoCD admin password** - `argocd-secret` in `argocd` namespace
- **Bitwarden access token** - `bitwarden-access-token` in `external-secrets` namespace

**Bitwarden-managed secrets** (via External Secrets Operator):
- **Tailscale OAuth** - `operator-oauth` in `tailscale` namespace

**Talos secrets** (gitignored):
- `talsecret.yaml` - Cluster PKI, generated by talhelper
- `.env` - Tailscale auth key for Talos extension

## Gotchas

- **Metrics-server TLS**: Uses `--kubelet-insecure-tls` because kubelet certs don't include Tailscale IP SANs
- **ArgoCD Chart.lock**: ArgoCD is the only infra chart with a Chart.lock (remote Helm dependency)
- **DaemonSet retry backoff**: After fixing a failing DaemonSet, may need `kubectl rollout restart` to clear backoff
- **Tailscale proxy pods**: Named `ts-<service>-<hash>-0` in the `tailscale` namespace
