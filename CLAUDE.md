# Claude Context for Homelab

## Git Workflow

Commit directly to main for routine changes. Use PRs for larger changes that benefit from review.

## Project Overview

GitOps-driven Kubernetes homelab running on Talos Linux with Tailscale networking. Tailnet: `catfish-mountain.ts.net`

## GitOps Pattern

Each app in `infra/` or `apps/` is a wrapper Helm chart:
- `Chart.yaml` - Declares upstream chart as dependency
- `values.yaml` - Configuration values (also read by ApplicationSet for metadata)
- `templates/` - Additional resources (e.g., Tailscale Ingress, Secrets)

The ApplicationSets scan for `values.yaml` files and generate ArgoCD Applications automatically.

### Adding a New App

1. Create directory: `kubernetes/infra/my-app/` or `kubernetes/apps/my-app/`
2. Add `Chart.yaml` with upstream dependency
3. Add `values.yaml` with configuration
4. Commit and push - ArgoCD auto-syncs

### Values.yaml Conventions

```yaml
# Optional: Override namespace (defaults to directory name)
namespace: custom-namespace

# Optional: Enable server-side apply for CRD-heavy charts
serverSideApply: true

# Tailscale exposure (if using tailscale-ingress template)
tailscale:
  enabled: true
  hostname: my-app  # becomes my-app.catfish-mountain.ts.net

# Upstream chart values nested under chart name
my-upstream-chart:
  key: value
```

## Important Patterns

### Tailscale Ingress

Services are exposed via Tailscale Ingress (not traditional Ingress controllers):
- Tailscale operator creates proxy pods that join the tailnet
- TLS certificates are automatically provisioned via Let's Encrypt
- Access via `https://<hostname>.catfish-mountain.ts.net`

Use the `tailscale-ingress` shared chart (see `charts/tailscale-ingress/README.md`):

```yaml
# Chart.yaml
dependencies:
  - name: tailscale-ingress
    version: 1.0.0
    repository: file://../../../charts/tailscale-ingress
    condition: tailscale-ingress.enabled

# values.yaml
tailscale-ingress:
  enabled: true
  ingresses:
    - name: tailscale
      hostname: my-app
      service:
        name: my-app-server
```

### Traefik Ingress (LAN)

For LAN-only HTTP access, use the `traefik-ingress` shared chart:

```yaml
# Chart.yaml
dependencies:
  - name: traefik-ingress
    version: 1.0.0
    repository: file://../../../charts/traefik-ingress
    condition: traefik-ingress.enabled

# values.yaml
traefik-ingress:
  enabled: true
  hostname: my-app.local
  service:
    name: my-app-server
    port: 8080
```

Add to `/etc/hosts`: `192.168.0.200    my-app.local`

### mDNS Advertisement

For LAN service discovery (Bonjour/Zeroconf), use the `mdns-config` shared chart:

```yaml
# Chart.yaml
dependencies:
  - name: mdns-config
    version: 1.0.0
    repository: file://../../../charts/mdns-config
    condition: mdns-config.enabled

# values.yaml
mdns-config:
  enabled: true
  services:
    - name: My App
      hostname: myapp        # becomes myapp.local
      ip: 192.168.0.200      # MetalLB or Traefik IP
      port: 80
      types:
        - type: _http._tcp
```

The central `mdns-advertiser` discovers labeled ConfigMaps and advertises them via mDNS.

### PodSecurity

Kubernetes enforces PodSecurity standards. Most namespaces use "baseline" but some require "privileged":
- `longhorn` - Storage operations require privileged access
- `metallb` - Speaker needs NET_RAW, hostNetwork for L2/ARP

Add namespace template with labels if privileged access needed:
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: {{ .Release.Namespace }}
  labels:
    pod-security.kubernetes.io/enforce: privileged
```

## Secrets Management

**Bootstrap secrets** (created during `bootstrap.sh`):
- **ArgoCD admin password** - `argocd-secret` in `argocd` namespace
- **Bitwarden access token** - `bitwarden-access-token` in `external-secrets` namespace

**Bitwarden-managed secrets** (via External Secrets Operator):
- **Tailscale OAuth** - `operator-oauth` in `tailscale` namespace

**Talos secrets** (gitignored):
- `talsecret.yaml` - Cluster PKI, generated by talhelper
- `.env` - Tailscale auth key for Talos extension

## Gotchas

- **Metrics-server TLS**: Uses `--kubelet-insecure-tls` because kubelet certs don't include Tailscale IP SANs
- **Chart.lock files**: ArgoCD is the only app with a Chart.lock. All other apps don't need one because ArgoCD runs `helm dependency build` at sync time. Don't suggest adding Chart.lock to apps.
- **Chart tarballs (.tgz)**: The `charts/` subdirectories contain `.tgz` files from `helm dependency build`. These are gitignored - don't suggest cleaning them up or committing them.
- **DaemonSet retry backoff**: After fixing a failing DaemonSet, may need `kubectl rollout restart` to clear backoff
- **Tailscale proxy pods**: Named `ts-<service>-<hash>-0` in the `tailscale` namespace
