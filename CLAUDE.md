# Claude Context for Homelab

## Git Workflow

Commit directly to main for routine changes. Use PRs for larger changes that benefit from review.

## Project Overview

GitOps-driven Kubernetes homelab running on Talos Linux with Tailscale networking. Tailnet: `catfish-mountain.ts.net`

## GitOps Pattern

Each app in `infra/` or `apps/` is a wrapper Helm chart:
- `Chart.yaml` - Declares upstream chart as dependency
- `values.yaml` - Configuration values (also read by ApplicationSet for metadata)
- `templates/` - Additional resources (e.g., Tailscale Ingress, Secrets)

The ApplicationSets scan for `values.yaml` files and generate ArgoCD Applications automatically.

### Adding a New App

1. Create directory: `kubernetes/infra/my-app/` or `kubernetes/apps/my-app/`
2. Add `Chart.yaml` with upstream dependency
3. Add `values.yaml` with configuration
4. Commit and push - ArgoCD auto-syncs

### Values.yaml Conventions

```yaml
# Optional: Override namespace (defaults to directory name)
namespace: custom-namespace

# Optional: Enable server-side apply for CRD-heavy charts
serverSideApply: true

# Tailscale exposure (if using tailscale-ingress template)
tailscale-ingress:
  ingresses:
    - name: tailscale
      hostname: my-app  # becomes my-app.catfish-mountain.ts.net
      service:
        name: my-app-server
        port: 80

# Upstream chart values nested under chart name
my-upstream-chart:
  key: value
```

## Important Patterns

### Tailscale Ingress

Services are exposed via Tailscale Ingress (not traditional Ingress controllers):
- Tailscale operator creates proxy pods that join the tailnet
- TLS certificates are automatically provisioned via Let's Encrypt
- Access via `https://<hostname>.catfish-mountain.ts.net`

Use the `tailscale-ingress` shared chart (see `charts/tailscale-ingress/README.md`):

```yaml
# Chart.yaml
dependencies:
  - name: tailscale-ingress
    version: 1.0.0
    repository: file://../../../charts/tailscale-ingress

# values.yaml
tailscale-ingress:
  ingresses:
    - name: tailscale
      hostname: my-app
      service:
        name: my-app-server
```

### Gateway API (Public + LAN)

For public and/or LAN HTTP access, use the `gateway-route` shared chart with Gateway API HTTPRoutes:

```yaml
# Chart.yaml
dependencies:
  - name: gateway-route
    version: 1.0.0
    repository: file://../../../charts/gateway-route

# values.yaml
gateway-route:
  routes:
    - name: public-lan
      hostnames:
        - myapp.fultonhuffman.com  # Public via Cloudflare Tunnel
        - myapp.local              # LAN via mDNS (add to /etc/hosts)
      service:
        name: my-app-server
        port: 8080
      mdns:                        # Optional: mDNS advertisement
        name: My App
        ip: 192.168.0.200          # Gateway MetalLB IP
        port: 80
```

**Private domains only (catfish-mountain.com):**
```yaml
gateway-route:
  routes:
    - name: private
      hostnames:
        - myapp.catfish-mountain.com  # Tailscale Split DNS only
      service:
        name: my-app-server
        port: 80
```

Add to `/etc/hosts` for .local: `192.168.0.200    myapp.local`

**Note:** `traefik-ingress` chart is deprecated. Use `gateway-route` for all new apps.

### mDNS Advertisement

For LAN service discovery (Bonjour/Zeroconf), use the `mdns-config` shared chart:

```yaml
# Chart.yaml
dependencies:
  - name: mdns-config
    version: 1.0.0
    repository: file://../../../charts/mdns-config

# values.yaml
mdns-config:
  services:
    - name: My App
      hostname: myapp        # becomes myapp.local
      ip: 192.168.0.200      # MetalLB or Traefik IP
      port: 80
      types:
        - type: _http._tcp
```

The central `mdns-advertiser` discovers labeled ConfigMaps and advertises them via mDNS.

### PodSecurity

Kubernetes enforces PodSecurity standards. Most namespaces use "baseline" but some require "privileged":
- `longhorn` - Storage operations require privileged access
- `metallb` - Speaker needs NET_RAW, hostNetwork for L2/ARP

Add namespace template with labels if privileged access needed:
```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: {{ .Release.Namespace }}
  labels:
    pod-security.kubernetes.io/enforce: privileged
```

## Secrets Management

**Bootstrap secrets** (created during `bootstrap.sh`):
- **ArgoCD admin password** - `argocd-secret` in `argocd` namespace
- **Bitwarden access token** - `bitwarden-access-token` in `external-secrets` namespace

**Bitwarden-managed secrets** (via External Secrets Operator):
- **Tailscale OAuth** - `operator-oauth` in `tailscale` namespace

**Talos secrets** (gitignored):
- `talsecret.yaml` - Cluster PKI, generated by talhelper
- `.env` - Tailscale auth key for Talos extension

## Gotchas

- **Check upstream chart values first**: Before adding configuration to an app's `values.yaml`, always run `helm show values <repo>/<chart>` to verify the correct parameter names. Different charts use different conventions (e.g., `extraVolumes` vs `additionalVolumes` vs `volumes`). Don't assume parameter names.
- **Metrics-server TLS**: Uses `--kubelet-insecure-tls` because kubelet certs don't include Tailscale IP SANs
- **Chart.lock files**: ArgoCD is the only app with a Chart.lock. All other apps don't need one because ArgoCD runs `helm dependency build` at sync time. Don't suggest adding Chart.lock to apps.
- **Chart tarballs (.tgz)**: The `charts/` subdirectories contain `.tgz` files from `helm dependency build`. These are gitignored - don't suggest cleaning them up or committing them.
- **DaemonSet retry backoff**: After fixing a failing DaemonSet, may need `kubectl rollout restart` to clear backoff
- **Tailscale proxy pods**: Named `ts-<service>-<hash>-0` in the `tailscale` namespace
